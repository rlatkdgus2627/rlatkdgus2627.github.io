---
title: "모놀리식 아키텍처 vs MSA vs 모듈러 모놀리식 아키텍처"
excerpt: "모놀리식 아키텍처, MSA, 모듈러 모놀리식 아키텍처에 대한 소개와 각각의 장단점, 다른 아키텍처로의 전환에 대한 내용"

categories:
  - Knowledge
tags:
  - [MSA, Modular Monoliths, Backend, Architecture]

permalink: /categories/backend_knowledge/모놀리식_아키텍처_vs_MSA_vs_모듈러_모놀리식_아키텍처/

toc: true
toc_sticky: true
toc_level: 1..1

date: 2025-05-03
last_modified_at: 2025-05-03
---

# Monolith vs Microservices vs Modular Monoliths What’s the Right Choice

이번 글에서는 소프트웨어 아키텍처 중 모놀리식 아키텍처, 마이크로서비스 아키텍처, 모듈러 모놀리식 아키텍처에 대해서 소개하고 각각의 접근 방식의 장단점에 대한 비교와 다른 아키텍처로의 변환에 대해서 설명하고자 한다.

## 서론 : 왜 소프트웨어 아키텍처 선택이 중요할까?

끊임없이 변화하는 소프트웨어 개발 특성상, 소프트웨어 아키텍처는 프로젝트의 성패를 좌우할 수 있으며, 적절한 소프트웨어 아키텍처 선택에 따라서 팀이 얼마나 효율적으로 애플리케이션을 구축하고, 확장하며, 유지관리를 할 수 있는지 결정할 수 있기 때문이다.

이를 위해 소프트웨어 아키텍처 선택에 있어 단순성, 유연성, 비용을 균형 있게 고려해야 하며, 이는 팀의 요구와 프로젝트 목표에 따라 달라진다.

# 모놀리식 아키텍처

![Monolith.png](https://rlatkdgus2627.github.io/assets/images/post_img/모놀리식_아키텍처_vs_MSA_vs_모듈러_모놀리식_아키텍처/Monolith.png)

모놀리식 아키텍처는 전통적인 방식으로, 프론트엔드, 백엔드, 데이터베이스 상호작용 등 모든 애플리케이션 로직이 하나의 거대한 코드베이스 안에 통합되어 있는 아키텍처로 **단일 코드베이스,** **단일 데이터베이스**를 가지고 **모든 구성 요소가 긴밀하게 연결**되어 있다. 

대표적으로 **MVC(Model - View - Controller)**구조가 있다.

## 주요 특징

- **단일 코드베이스와 배포 단위** : 모놀리식 시스템에서는 모든 애플리케이션 로직이 하나의 코드베이스에 존재합니다. 따라서 기능 요소들이 같은 프로젝트 안에서 개발되며, 모든 개발자가 동일한 저장소에서 작업한다. 전체 어플리케이션도 하나로 컴파일되고 함께 배포되기 때문에 기능 수정 시 전체 애플리케이션을 다시 배포해야 한다.
- **공유 데이터베이스 및 강한 결합** : 모놀리식 애플리케이션은 하나의 관계형 데이터베이스를 가지고, 이 데이터베이스가 모든 기능을 지원합니다. 따라서 시스템의 구성 요소간의 강한 의존성이 존재하며, 데이터베이스가 다운되면 전체 애플리케이션이 작동하지 않게 된다.
- **초기 개발 용이성**: 단일 프로그래밍 언어나 프레임워크를 사용해 간단히 구축할 수 있으며, 서비스 간 통신이 없기 때문에 로컬 개발과 테스트도 단순해 진다.
- **시간이 지날수록 확장이 어려움**: 애플리케이션이 성장하면서 프로젝트 규모가 커지게 되면, 코드베이스가 복잡해지고 배포가 까다로워지기 때문에 확장성에 재약이 생긴다. 또한 개별 구성 요소만 독립적으로 확장하는 것이 불가능해 병목 현상이 발생할 수 있다.

## 장점

1. **개발이 비교적 쉽다(소규모 프로젝트 한정)** : 모든 요소가 하나의 위치에 통합되어 있기 때문에 개발이 상대적으로 간단하며, 여러 코드베이스를 다루거나 서비스 간 통신 방법을 이나 네트워크 요청으로 인한 지연을 신경 쓸 필요가 없다.
2. **테스트가 용이하다** : 전체 시스템이 하나의 단위이기 때문에 프론트엔드, 백엔드, DB등 모든 부분을 한 번에 점검할 수 있고, 외부 API mocking이나 네트워크 특성 시뮬레이션을 할 필요가 없다.
3. **배포가 단순하다 :** 하나의 애플리케이션만 배포하므로, 단일 명령으로 전체를 라이브 상태로 전환할 수 있습니다. 그리고 여러 배포를 동시에 관리하거나, 버전 충돌을 고려할 필요가 없고, 모두가 동일한 코드베이스를 사용하기 때문에 협업의 혼란이 줄어든다.

<aside>
💡

소규모 프로젝트나 개발 초기에는 빠르게 개발할 수 있고, 테스트나 배포가 단순하기 때문에 유리하다.

</aside>

## 단점

1. **확장에 제약이 있다** : 가장 큰 문제점으로, 특정 서비스에 트래픽이 급증한다고 해서 그 부분만 확장할 수 없고 전체 애플리케이션을 확장해야 한다. 이 때문에 필요하지 않은 부분까지 같이 확장해야 하므로 비효율적이다.
2. **한 부분의 수정이나 오류가 프로젝트 전체에 영향을 줄 수 있다** : 모놀리식 구조는 모든 구성 요소가 긴밀하게 연결되어 있고, 단일 데이터베이스를 사용으로 인한 구성 요소간의 강한 의존성이 존재한다. 이 때문에 한 부분을 수정하거나 데이터베이스가 다운이 되면 전체 기능이 동작하지 않는 경우가 발생한다. 변경 사항마다 전체 시스템에 걸쳐 광범위한 테스트가 필요하기 때문에 개발 속도가 느려지고, 유지보수가 힘들어 진다.
3. **기술 스택에 갇히게 된다** : 시스템이 하나의 기술 스택에 고정되어 버리기 때문에, 특정 부분을 업데이트하려면 전체 코드베이스를 다시 고민해야 한다. 결국에는 대대적인 개편 없이 오래된 도구나 기술을 계속 사용하고 방향을 전환하기 어려워지게 된다.

<aside>
💡

프로젝트 규모가 커짐에 따라 전체 시스템 구조 파악과 수정 시 영향도 파악이 힘들어 프로젝트 확장에 어려움을 느끼게 된다.

결국에는 X나 에어비앤비도 모놀리식 아키텍처에서 MSA로 전환하게 되었다.

</aside>

# 마이크로서비스 아키텍처

마이크로서비스 아키텍처(줄여서 MSA)는 애플리케이션을 여러 개의 작고 독립적인 서비스로 나누어 이들이 협력하여 하나의 완전한 시스템을 구성하는 방식으로, 각 서비스는 한 가지 일에 집중하며 **자체 데이터베이스**와 **배포 과정**을 가진 하나의 작은 애플리케이션처럼 동작한다.

이 서비스들은 정의된 채널(API, 메시지 등)을 통해 통신하며, 이는 마치 조직 내 부서들이 이메일을 주고받으며 협업하는 방식과 유사하다.

### 예시

![MSAexample.png](https://rlatkdgus2627.github.io/assets/images/post_img/모놀리식_아키텍처_vs_MSA_vs_모듈러_모놀리식_아키텍처/MSAexample.png)

- 유저 서비스는 회원가입, 인증, 프로필 관리를 담당
- 결제 서비스는 거래 처리를 담당
- 카탈로그 서비스는 사용자에게 보여줄 상품 재고를 관리

## 특징

- **서비스의 독립적인 배포** : 각 마이크로서비스는 독립적으로 개발, 배포, 확장되기 때문에 변경된 서비스에 대해서만 배포를 진행하면 되고, 각 서비스는 자체 데이터베이스, 기술 스택, 런타임 환경을 가지기 때문에 실험 및 업데이트를 빠르게 진행할 수 있다.
- **API를 통한 서비스 간 통신** : 서비스들이 서로 독립적이기 때문에 REST API, gRPC, 메시지 브로커를 통한 서비스 간의 통신을 해야 한다.
- **팀 단위로 분산 개발 가능** : 팀마다 서로 자기가 개발하는 서비스만 책임을 지게 되고, 자신에게 맞는 기술 스택을 자유롭게 선택할 수 있다. 병렬로 개발할 수 있어 배포 속도가 빨라진다.

<aside>
💡

기업들은 일정 수준 이상의 성장에 도달하면 모놀리식 구조에서 마이크로서비스로 전환하는 경우가 많다.

</aside>

## 장점

1. **부분 확장과 개별 배포에 유리** : 모놀리식 구조와는 다르게 수요가 많은 부분만 확장할 수 있고, 요구사항을 반영후 배포할 때 해당 부분만 배포하면 되기 때문에 전체 서비스의 중단 없이 CI/CD를 가능하게 한다.
2. **기술 스택의 유연성** : 각 서비스는 서로 다른 기술 스택을 사용할 수 있으므로, 팀마다 기능에 최적화된 도구를 선택할 수 있다. 예를 들어 결제 서비스는 보안성과 안정성이 높은 기술을 사용하고, 카탈로그 서비스는 가볍고 빠른 기술을 사용할 수 있다.
3. **장애 격리가 가능하다** : 하나의 서비스에 장애가 발생해도 다른 서비스는 계속 작동할 수 있기 때문에, 하나의 장애로 전체 시스템이 중단되는 것을 방지한다.

<aside>
💡

서비스를 독립적으로 개발·배포·운영할 수 있어 확장성과 유지보수성이 뛰어나다.

</aside>

## 단점

1. **여러 서비스를 조율하는 것은 복잡하다** : 여러 서비스를 독립적으로 배포, 운영해야 하므로 시스템 전체의 복잡성이 증가하고 서비스 간 통신, 장애 처리, 버전 호환성을 고려해야 한다. 모든 서비스가 제대로 협업하도록 보장하기 위해서 Kubernetes와 같은 오케스트레이션 도구와 팀 간의 면밀한 계획이 요구된다.
2. **운영 인프라 비용 증가** : 각 서비스는 자체 리소스를 필요로 하**고,** 많은 서비스를 운영하려면 더 많은 서버, 데이터베이스, 인프라가 필요하므로 소규모 프로젝트에서 초기 비용이 크게 증가할 수 있다.
3. **데이터 일관성 유지의 어려움** :  MSA 아키텍처의 가장 큰 단점으로, 독립적인 DB를 가지고 있기 때문에 특정 서비스에서 데이터의 변동이 발생하면 그 변경 사항이 다른 서비스에도 반영이 되어야 하며, 분산 트랜잭션을 피하면서 데이터 정합성을 유지해야 하는 어려움이 있다. 시스템 설계 단계에서 궁극적 일관성과 이벤트 기반 설계를 고려해야 한다.

> Kubernetes : 컨테이너화된 애플리케이션을 자동으로 배포, 스케일링, 운영할 수 있는 오케스트레이션 플랫폼으로 선언적 상태 관리 방식을 통해 사용자가 이런 상태로 되어야 한다라고 정의를 하면 시스템이 그 상태로 수렴하도록 반복적으로 조정을 한다.
> 

> 궁극적 일관성(Eventual Consistency) : 모든 노드가 즉시 동일한 상태를 갖지는 않지만, 시간이 지나면 결국 일관된 상태로 수렴하는 것
> 

<aside>
💡

서비스 간 복잡한 통신과 데이터 일관성 관리로 인해 운영과 설계 난이도가 높다.

</aside>

# 모듈러 모놀리식 아키텍처

![Modular_Monoliths.png](https://rlatkdgus2627.github.io/assets/images/post_img/모놀리식_아키텍처_vs_MSA_vs_모듈러_모놀리식_아키텍처/Modular_Monoliths.png)

모듈러 모놀리식은 **모놀리식의 단순함**과 **마이크로서비스의 구조적 분리**를 결합한 아키텍처로, 시스템을 독립적인 서비스로 분리하지 않고 **단일 코드베이스**와 **단일 배포 단위를 유지**하지만, **고유한 기능을 처리하는 모듈로 구분**하여 모놀리식보다 체계적인 조직화 수준을 도입하여 관리와 확장을 수월하게 한다.

모듈은 코드베이스 내에서 각각의 폴더나 네임스페이스처럼 분리되어 있으며, 각 기능을 명확하게 구분하고 과도한 상호 의존성을 줄이도록 설계되어 있다. 그래서 모놀리식과 마찬가지로 하나의 시스템으로 설계되지만, 코드의 정리와 관리를 쉽게 만들어주고 기존 모놀리식에서 발생하는 얽힘을 줄인다.

## 주요 특징

- **모듈화된 코드 구성**: 명확하게 정의되고 서로간의 경계를 가진 모듈들을 기반으로 설계되며, 각 모듈은 개별적인 비즈니스 기능을 담당하고, 서로 직접적으로 간섭하지 않는다. 모듈 간 통신은 내부 API나 이벤트 기반 메시징을 통해 이루어지며, 서로의 로직에 강하게 결합되지 않는다. 또한 각 모듈은 캡슐화가 적용되어 각 모듈이 자체 데이터를 관리하고, 하나의 거대한 공용 데이터베이스 스키마를 공유하지 않는다.
- **필요 시 마이크로서비스로의 손쉬운 전환**: 각 모듈은 서로 독립적이기 때문에 모놀리식 시스템을 분해하는 대신, 시간에 따라 개별 모듈들을 마이크로서비스로 점진적으로 전환할 수 있다. 모듈 간 통신이 이미 API 기반이기 때문에, 네트워크 기반 마이크로서비스로의 전환도 최소한의 변경만으로 가능하다. 데이터베이스 역시 모듈별로 분리된 스키마를 가질 수 있어, 단일 데이터베이스에 대한 의존도도 줄일 수 있다.

<aside>
💡

MSA는 물리적으로 서비스를 나누지만, 모듈러 모놀리식은 논리적으로 서비스를 나눈다.

</aside>

## 장점

1. **단일 코드베이스 구성에서 오는 장점** : 모놀리식 구조의 장점을 그대로 계승한다. 개발, 테스트, 배포 과정이 간단하고, MSA처럼 여러 서비스간의 분산과 통신을 고려하지 않아도 된다. 또한 다수의 마이크로서비스를 유지하는 것보다 비용이 적게 들고, 고급 오케스트레이션 도구가 필요 없기 때문에 운영 오버헤드가 낮다.
2. **모듈화된 구조에서 오는 진화 용이성** : 특정 모듈의 수정이나 별도 서비스로의 추출이 필요할 경우, 명확한 경계가 이를 쉽게 만들어 시스템의 유연성을 높인다.

<aside>
💡

모놀리식 구조의 장점을 가져가면서도, 모듈이 논리적으로 분리되어 있어 수정에 용이하다.

</aside>

## 단점

1. **단일 코드베이스 구성에서 오는 단점** : 여전히 전체 애플리케이션이 하나의 단위로 확장되어야 하고, 특정 모듈에 부하가 집중되면, 다른 모듈은 idle 상태임에도 전체 시스템을 확장해야 하므로 비효율이 발생한다. 그리고 하나의 기술 스택을 사용해야 하며, 하나의 오류에 전체 시스템이 영향을 받을 수 있다.
2. **은밀한 의존성의 위험** : 주의 깊게 관리하지 않으면 의도치 않은 방식으로 한 모듈이 다른 모듈에 의존하는 경우가 생길 수 있으며, 이로 인해 명목상은 모듈화되어 있어도 실제로는 복잡하게 얽힌 시스템이 될 수 있다.

<aside>
💡

단일 코드베이스에서 발생하는 근본적인 문제(확장이 어려움, 단일 기술 스택, 하나의 오류가 전체 시스템에 영향)는 해결이 불가능하고, 관리를 잘 못했을 경우에 모놀리식 구조와 동일해 질 수 있다.

</aside>

# 다른 아키텍처로의 변환

X나 에어비앤비도 모놀리식 아키텍처에서 MSA로 전환했던 것처럼, 소프트웨어 시스템이 성장함에 따라, 처음 선택한 아키텍처가 팀의 필요나 사용자 요구를 지속적으로 만족시키지 못할 수 있다. 따라서 아키텍처를 전환하는 것은 단순히 유행을 따르는 것이 아니라, **성능 병목 현상**, **팀 생산성**, **예산 제약**과 같은 문제를 해결하기 위한 전략이다.

## 모놀리식 아키텍처를 MSA로

급격한 트래픽 증가, 하나의 코드베이스 내에서 증가하는 복잡도 처리의 어려움, 성능 병목이나 확장성의 한계 때문에 MSA로 전환을 고려하게 된다. 보통 **Strangler Fig** 패턴을 통해 MSA로 전환을 추진한다.

### Strangler Fig 패턴

![Strangler_Fig.png](https://rlatkdgus2627.github.io/assets/images/post_img/모놀리식_아키텍처_vs_MSA_vs_모듈러_모놀리식_아키텍처/Strangler_Fig.png)

기존 모놀리식 시스템을 점진적으로 마이크로서비스로 전환할 때 사용하는 대표적인 전략으로, 총 3단계의 과정을 통해 각 기능을 하나의 마이크로서비스로 옮긴다.

1. 서비스 분리(Extracting the Service) : Feature A를 모놀리식에서 분리하여 별도의 서비스(Service A)로 만든다. 
2. 읽기 요청 이전(Migrating the Reads):  Feature A에 대한 **읽기(read)** 요청을 Service A가 처리하도록 변경한다.
3. 쓰기 요청 이전(Migrating the Writes): Feature A에 대한 **쓰기(write)** 요청까지 Service A가 처리하게 만들고 Feature A를 제거한다.

### 기술적 통찰

- 리펙토링 : 도메인 주도 설계(DDD)를 적용해 기능을 명확한 경계 컨텍스트로 나누고, 가장 병목이 심한 기능부터 분리하고 나머지는 모놀리식으로 유지해 안정성을 확보한다.
- 통신 : 서비스 간에는 API(REST, gRPC)와 메시지 큐(RabbitMQ 등)를 이용해 느슨한 결합을 유지한다.
- 데이터 : 각 서비스는 자체 데이터베이스를 사용하도록 설계하고 데이터 일관성은 궁극적 일관성으로 처리되며, 이벤트 소싱과 같은 패턴으로 관리한다.

> 도메인 주도 설계(DDD) : 비즈니스의 핵심 도메인에 집중하여 소프트웨어 구조를 설계
>
> ex)
> 
> - `Order` 도메인: 주문 생성, 취소, 결제 상태 관리
> - `Product` 도메인: 상품 정보, 재고, 가격
> - `Customer` 도메인: 회원가입, 주소, 등급 관리
> 
> 느슨한 결합(Loose Coupling) : 소프트웨어 설계에서 구성 요소(클래스, 모듈, 서버) 간의 상호 의존성을 최소화하는 설계 원칙
> 

<aside>
💡

Strangler Fig 패턴은 안정성을 해치지 않으면서 점진적으로 MSA로 전환하기 위한 방법이다.

</aside>

## 모놀리식 아키텍처를 모듈러 모놀리식 아키텍처로

이 경우에도 전환의 주요 계기는 모놀리식 아키텍처에서 MSA로 가는 경우와 비슷하며, 모놀리식 코드베이스가 점점 혼란스러워지고, 개발 속도를 저해하거나 오류 가능성이 높아져 코드의 구조적인 정리가 필요하다고 느끼지만, 마이크로서비스로 전환하기엔 너무 복잡하다고 판단될 때 전환을 고려한다.

모듈러 모놀리식은 **단일 배포 유닛의 단순함은 유지**하면서도, **코드를 명확한 모듈로 분리**하여 유지보수를 용이하게 한다. 그리고 분산 시스템의 오버헤드 없이도 높은 구조화 효과를 얻을 수 있다.

### 기술적 통찰

- 리펙토링 : 마찬가지로 도메인 주도 설계(DDD)를 적용해 코드베이스를 비즈니스 도메인 기준으로 분할하고, 명확한 모듈 경계를 설정한다.
- 격리 : 데이터베이스는 공유하더라도 스키마나 네임스페이스를 이용해 모듈 간 데이터 접근을 제한하고 분리한다.
- 내부 API : 모듈 간 상호작용은 정의된 함수나 이벤트를 통해 수행하며, 공유 변수 같은 직접적인 의존성을 피한다.

<aside>
💡

모듈러 모놀리식 아키텍처로의 전환은 단일 코드베이스의 유지 관리성을 높이고, 분산 시스템으로의 복잡한 전환 없이도 구조적 이점을 얻을 수 있는 방법이다.

</aside>

## 모듈러 모놀리식 아키텍처를 MSA로

이 전환의 주요 계기는 특정 모듈이 **독립적인 확장, 배포, 혹은 별도의 기술 스택**을 필요로 하거나, **성능 병목**이나 **기능적 요구사항**이 다른 모듈들과 달라질 때 고려를 하게 된다.

### 기술적 통찰

- 리펙토링 : 해당 모듈의 경계를 명확하게 정의하고, 외부 API를 통해 모놀리식과의 상호작용을 먼저 분리한다.
- 데이터 : 모듈의 데이터를 전용 데이터베이스로 이관하고 동기화한다. (공유 DB → 전용 DB)
- 통신 : 마이크로서비스로 분리된 후에도 모놀리식과의 조율이 필요할 수 있으므로, API 또는 이벤트 기반 통신(Event-Driven Architecture)을 사용하여 실시간 상호작용을 유지한다.

# 정리

## 아키텍처 비교

|  | 모놀리식 | 모듈러 모놀리식 | 마이크로서비스 |
| --- | --- | --- | --- |
| 설명 | 시스템을 하나의 코드베이스에 통합 | 하나의 코드베이스에 통합하되, 기능별로 모듈을 만들어 **논리적으로 분리**함 | 시스템을 독립적인 마이크로서비스로 **물리적으로 분리,** 각 마이크로서비스는 **독립적인 DB를 가짐** |
| 장점 | 개발, 테스트, 배포가 단순<br>서비스간의 분산과 통신을 고려하지 않아도 됨<br>초기 비용이 저렴 | **모놀리식의 모든 장점** + 구조적 유연성이 추가됨 | 부분 확장, 다양한 기술 스택, 장애 격리, CI/CD 가능, 동시 협업 가능 |
| 단점 | **모듈러 모놀리식의 모든 단점** + 시스템 규모가 커지면 의존성 때문에 매우 복잡해짐 | 기술 스택 고정, 오류 발생시 전체 다운, 단독 확장 불가능, 숨은 의존성 문제  | 운영 복잡성 증가, 비용 상승, 데이터 일관성 문제 |

## 아키텍처 전환

시스템의 규모가 커지고 복잡해 짐에 따라 성능 병목 해결, 확장성, 구조화, 다양한 기술 스택 활용 때문에 모놀리식 아키텍처에서 다른 아키텍처로의 전환을 하는 편이다.

1. 모놀리식 아키텍처 → MSA : Strangler Fig 패턴
2. 모놀리식 아키텍처 → 모듈러 모놀리식 아키텍처 → MSA